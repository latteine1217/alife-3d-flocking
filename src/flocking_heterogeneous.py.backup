"""
Heterogeneous 3D Flocking System - Agent ç•°è³ªæ€§æ“´å±•

æ–°å¢åŠŸèƒ½ï¼š
    â€¢ Agent Types: Explorer / Follower / Leaderï¼ˆä¸åŒè¡Œç‚ºç‰¹å¾µï¼‰
    â€¢ Individual Parameters: æ¯å€‹ agent æœ‰ç¨ç«‹çš„ beta, eta, v0, mass
    â€¢ Goal-directed Behavior: ç›®æ¨™å°å‘è¡Œç‚ºï¼ˆgoal seekingï¼‰
    â€¢ Field of View (FOV): è¦–é‡é™åˆ¶ï¼ˆåªèƒ½çœ‹åˆ°å‰æ–¹ 120 åº¦ç¯„åœï¼‰

è¨­è¨ˆç†å¿µï¼š
    â€¢ ç¹¼æ‰¿ Flocking3Dï¼Œæœ€å°åŒ–ç¨‹å¼ç¢¼é‡è¤‡
    â€¢ å‘å¾Œç›¸å®¹ï¼šå¯é€€åŒ–ç‚ºå‡è³ªç³»çµ±
    â€¢ æ¨¡çµ„åŒ–ï¼šæ¯å€‹åŠŸèƒ½å¯ç¨ç«‹å•Ÿç”¨/ç¦ç”¨
"""

import taichi as ti
import numpy as np
from dataclasses import dataclass
from typing import Optional, List, Dict
from enum import IntEnum

# åŒ¯å…¥åŸºç¤é¡åˆ¥
from flocking_3d import Flocking3D, FlockingParams
from obstacles import ObstacleSystem, ObstacleConfig
from resources import ResourceSystem, ResourceConfig


class AgentType(IntEnum):
    """Agent è¡Œç‚ºé¡å‹"""

    FOLLOWER = 0  # è¿½éš¨è€…ï¼šå¼·å°é½Šã€ä½ noiseã€æ¨™æº–é€Ÿåº¦
    EXPLORER = 1  # æ¢ç´¢è€…ï¼šå¼±å°é½Šã€é«˜ noiseã€å¿«é€Ÿ
    LEADER = 2  # é ˜å°è€…ï¼šä¸­å°é½Šã€ä¸­ noiseã€å¿«é€Ÿã€ç›®æ¨™å°å‘
    PREDATOR = 3  # æ é£Ÿè€…ï¼šæ¥µå¿«é€Ÿåº¦ã€è¿½æ•å…¶ä»– agentsã€ç¨è¡Œ


@dataclass
class AgentTypeProfile:
    """Agent é¡å‹çš„è¡Œç‚ºç‰¹å¾µ"""

    name: str
    beta: float  # å°é½Šå¼·åº¦
    eta: float  # Vicsek noise å¼·åº¦
    v0: float  # ç›®æ¨™é€Ÿåº¦
    mass: float  # è³ªé‡
    goal_strength: float = 0.0  # ç›®æ¨™å°å‘å¼·åº¦ï¼ˆ0 = ç„¡ç›®æ¨™ï¼‰
    hunt_range: float = 20.0  # è¿½æ•ç¯„åœï¼ˆåƒ…ç”¨æ–¼æ é£Ÿè€…ï¼‰
    attack_range: float = 2.0  # æ”»æ“Šç¯„åœï¼ˆåƒ…ç”¨æ–¼æ é£Ÿè€…ï¼‰


# é è¨­é¡å‹ profiles
DEFAULT_PROFILES = {
    AgentType.FOLLOWER: AgentTypeProfile(
        name="Follower", beta=1.5, eta=0.05, v0=1.0, mass=1.0, goal_strength=0.0
    ),
    AgentType.EXPLORER: AgentTypeProfile(
        name="Explorer", beta=0.5, eta=0.3, v0=1.3, mass=0.8, goal_strength=0.0
    ),
    AgentType.LEADER: AgentTypeProfile(
        name="Leader", beta=1.0, eta=0.15, v0=1.4, mass=1.2, goal_strength=2.0
    ),
    AgentType.PREDATOR: AgentTypeProfile(
        name="Predator",
        beta=0.0,  # ä¸å°é½Šï¼ˆç¨è¡Œï¼‰
        eta=0.1,  # ä½ noiseï¼ˆå°ˆæ³¨è¿½æ•ï¼‰
        v0=1.3,  # å¿«é€Ÿä½†ä¸éåº¦ï¼ˆåŸ 1.8 â†’ 1.3ï¼Œæ¯” Explorer å¿«ä¸€é»ï¼‰
        mass=1.5,  # è¼ƒé‡ï¼ˆæ”»æ“ŠåŠ›å¼·ï¼‰
        goal_strength=0.0,  # ä¸è¿½ç›®æ¨™é»
        hunt_range=20.0,  # è¿½æ•ç¯„åœ
        attack_range=2.0,  # æ”»æ“Šç¯„åœ
    ),
}


@ti.data_oriented
class HeterogeneousFlocking3D(Flocking3D):
    """æ”¯æ´ Agent ç•°è³ªæ€§çš„ 3D Flocking ç³»çµ±"""

    def __init__(
        self,
        N: int,
        params: FlockingParams,
        agent_types: Optional[List[int]] = None,
        type_profiles: Optional[Dict[int, AgentTypeProfile]] = None,
        enable_fov: bool = True,
        fov_angle: float = 120.0,
        max_obstacles: int = 32,
        max_groups: int = 32,
        max_resources: int = 32,
    ):
        """
        åˆå§‹åŒ–ç•°è³ªæ€§ç³»çµ±

        Args:
            N: ç²’å­æ•¸é‡
            params: åŸºç¤ç‰©ç†åƒæ•¸ï¼ˆä½œç‚ºé è¨­å€¼ï¼‰
            agent_types: æ¯å€‹ agent çš„é¡å‹ï¼ˆé•·åº¦ç‚º N çš„åˆ—è¡¨ï¼‰
            type_profiles: é¡å‹ profile å­—å…¸ï¼ˆè¦†è“‹é è¨­å€¼ï¼‰
            enable_fov: æ˜¯å¦å•Ÿç”¨è¦–é‡é™åˆ¶
            fov_angle: è¦–é‡è§’åº¦ï¼ˆåº¦æ•¸ï¼Œé è¨­ 120 åº¦ï¼‰
            max_obstacles: æœ€å¤§éšœç¤™ç‰©æ•¸é‡
            max_groups: æœ€å¤§ç¾¤çµ„æ•¸é‡ï¼ˆç”¨æ–¼ group detectionï¼‰
            max_resources: æœ€å¤§è³‡æºæ•¸é‡ï¼ˆç”¨æ–¼ foragingï¼‰
        """
        # å…ˆåˆå§‹åŒ–çˆ¶é¡åˆ¥
        super().__init__(N, params)

        # è¦–é‡é™åˆ¶åƒæ•¸
        self.enable_fov = enable_fov
        self.fov_cos_angle = np.cos(np.radians(fov_angle / 2.0))  # åŠè§’çš„ cos å€¼

        # é¡å‹ profilesï¼ˆä½¿ç”¨é è¨­æˆ–è‡ªè¨‚ï¼‰
        self.type_profiles = type_profiles if type_profiles else DEFAULT_PROFILES

        # å€‹é«”åƒæ•¸ fields
        self.beta_individual = ti.field(ti.f32, N)
        self.eta_individual = ti.field(ti.f32, N)
        self.v0_individual = ti.field(ti.f32, N)
        self.mass_individual = ti.field(ti.f32, N)
        self.agent_type = ti.field(ti.i32, N)

        # ç›®æ¨™å°å‘åƒæ•¸
        self.goal = ti.Vector.field(3, ti.f32, N)  # æ¯å€‹ agent çš„ç›®æ¨™ä½ç½®
        self.has_goal = ti.field(ti.i32, N)  # æ˜¯å¦æœ‰ç›®æ¨™ï¼ˆ0/1ï¼‰
        self.goal_strength = ti.field(ti.f32, N)  # ç›®æ¨™å°å‘å¼·åº¦

        # éšœç¤™ç‰©ç³»çµ±
        self.obstacles = ObstacleSystem(max_obstacles=max_obstacles)

        # ç¾¤çµ„åµæ¸¬ç³»çµ±
        self.max_groups = max_groups
        self.group_id = ti.field(ti.i32, N)  # æ¯å€‹ agent çš„ç¾¤çµ„ IDï¼ˆ-1 = ç„¡ç¾¤çµ„ï¼‰
        self.group_size = ti.field(ti.i32, max_groups)  # æ¯å€‹ç¾¤çµ„çš„å¤§å°
        self.group_centroid = ti.Vector.field(3, ti.f32, max_groups)  # ç¾¤çµ„è³ªå¿ƒ
        self.group_velocity = ti.Vector.field(3, ti.f32, max_groups)  # ç¾¤çµ„å¹³å‡é€Ÿåº¦
        self.group_active = ti.field(ti.i32, max_groups)  # ç¾¤çµ„æ˜¯å¦æœ‰æ•ˆï¼ˆ0/1ï¼‰

        # åˆå§‹åŒ–ç¾¤çµ„ç‚ºç„¡æ•ˆ
        self.group_id.fill(-1)
        self.group_active.fill(0)

        # ç¾¤çµ„æª¢æ¸¬é »ç‡æ§åˆ¶
        self.group_detection_interval = 5  # æ¯ 5 æ­¥æª¢æ¸¬ä¸€æ¬¡ï¼ˆåŸ 3 â†’ 5ï¼‰
        self.step_counter = 0  # æ­¥æ•¸è¨ˆæ•¸å™¨

        # ===== Spatial Grid for Group Detection =====
        # ç”¨æ–¼åŠ é€Ÿç¾¤çµ„æª¢æ¸¬çš„ç©ºé–“ç¶²æ ¼ç³»çµ±
        # cell_size è¨­ç‚º r_clusterï¼ˆé è¨­ 5.0ï¼‰ï¼Œç¢ºä¿é„°å±…ä¸€å®šåœ¨ 3Ã—3Ã—3 ç¯„åœå…§
        self.grid_cell_size = 5.0  # å°‡åœ¨ update_groups() ä¸­æ ¹æ“š r_cluster å‹•æ…‹è¨­ç½®
        self.grid_resolution = (
            16  # åˆå§‹å€¼ï¼Œbox_size=50 æ™‚ç‚º 50/5 â‰ˆ 10ï¼Œè¨­ç‚º 16 é ç•™ç©ºé–“
        )
        self.max_agents_per_cell = 32  # æ¯å€‹ cell æœ€å¤šå®¹ç´çš„ agent æ•¸é‡

        # Grid è³‡æ–™çµæ§‹
        total_cells = self.grid_resolution**3
        self.agent_cell_id = ti.field(ti.i32, N)  # æ¯å€‹ agent æ‰€åœ¨çš„ cell ID
        self.cell_count = ti.field(ti.i32, total_cells)  # æ¯å€‹ cell ä¸­çš„ agent æ•¸é‡
        self.cell_agents = ti.field(
            ti.i32, (total_cells, self.max_agents_per_cell)
        )  # cell â†’ agents æ˜ å°„

        # åˆå§‹åŒ–
        self.agent_cell_id.fill(-1)
        self.cell_count.fill(0)

        # è³‡æº/è¦“é£Ÿç³»çµ±
        self.resources = ResourceSystem(max_resources=max_resources)

        # Agent è¦“é£Ÿç‹€æ…‹
        self.agent_energy = ti.field(ti.f32, N)  # ç•¶å‰èƒ½é‡
        self.agent_target_resource = ti.field(ti.i32, N)  # ç›®æ¨™è³‡æº IDï¼ˆ-1 = ç„¡ç›®æ¨™ï¼‰
        self.energy_threshold = 30.0  # é–‹å§‹è¦“é£Ÿçš„èƒ½é‡é–¾å€¼
        self.energy_consumption_rate = 0.1  # æ¯æ­¥æ¶ˆè€—çš„èƒ½é‡

        # åˆå§‹åŒ–èƒ½é‡
        self.agent_energy.fill(100.0)
        self.agent_target_resource.fill(-1)

        # æ é£Ÿè€…ç³»çµ±
        self.agent_target_prey = ti.field(
            ti.i32, N
        )  # æ é£Ÿè€…çš„ç›®æ¨™çµç‰© IDï¼ˆ-1 = ç„¡ç›®æ¨™ï¼‰
        self.agent_alive = ti.field(ti.i32, N)  # agent æ˜¯å¦å­˜æ´»ï¼ˆ0/1ï¼‰
        self.predator_hunt_range = ti.field(ti.f32, N)  # è¿½æ•ç¯„åœï¼ˆåƒ…æ é£Ÿè€…ä½¿ç”¨ï¼‰
        self.predator_attack_range = ti.field(ti.f32, N)  # æ”»æ“Šç¯„åœï¼ˆåƒ…æ é£Ÿè€…ä½¿ç”¨ï¼‰

        # åˆå§‹åŒ–
        self.agent_target_prey.fill(-1)
        self.agent_alive.fill(1)  # æ‰€æœ‰ agent åˆå§‹å­˜æ´»

        # åˆå§‹åŒ– agent é¡å‹èˆ‡åƒæ•¸
        if agent_types is None:
            # é è¨­ï¼šå…¨éƒ¨æ˜¯ FOLLOWER
            agent_types = [AgentType.FOLLOWER] * N

        self._init_agent_types(agent_types)

        # è¼¸å‡ºç³»çµ±è³‡è¨Š
        type_counts = self._count_types()
        print(f"[HeterogeneousFlocking3D] Agent composition:")
        for atype, count in type_counts.items():
            profile = self.type_profiles[atype]
            print(
                f"  {profile.name}: {count}/{N} "
                f"(beta={profile.beta:.2f}, eta={profile.eta:.2f}, v0={profile.v0:.2f})"
            )
        if enable_fov:
            print(f"  FOV: {fov_angle:.0f} degrees")

    def _init_agent_types(self, agent_types: List[int]):
        """åˆå§‹åŒ– agent é¡å‹èˆ‡å€‹é«”åƒæ•¸"""
        assert len(agent_types) == self.N, "agent_types é•·åº¦å¿…é ˆç­‰æ–¼ N"

        # è½‰æ›ç‚º numpy arrays
        beta_arr = np.zeros(self.N, dtype=np.float32)
        eta_arr = np.zeros(self.N, dtype=np.float32)
        v0_arr = np.zeros(self.N, dtype=np.float32)
        mass_arr = np.zeros(self.N, dtype=np.float32)
        goal_strength_arr = np.zeros(self.N, dtype=np.float32)
        hunt_range_arr = np.zeros(self.N, dtype=np.float32)
        attack_range_arr = np.zeros(self.N, dtype=np.float32)
        type_arr = np.array(agent_types, dtype=np.int32)

        for i, atype in enumerate(agent_types):
            profile = self.type_profiles[atype]
            beta_arr[i] = profile.beta
            eta_arr[i] = profile.eta
            v0_arr[i] = profile.v0
            mass_arr[i] = profile.mass
            goal_strength_arr[i] = profile.goal_strength
            hunt_range_arr[i] = profile.hunt_range
            attack_range_arr[i] = profile.attack_range

        # ä¸Šå‚³åˆ° GPU
        self.beta_individual.from_numpy(beta_arr)
        self.eta_individual.from_numpy(eta_arr)
        self.v0_individual.from_numpy(v0_arr)
        self.mass_individual.from_numpy(mass_arr)
        self.goal_strength.from_numpy(goal_strength_arr)
        self.predator_hunt_range.from_numpy(hunt_range_arr)
        self.predator_attack_range.from_numpy(attack_range_arr)
        self.agent_type.from_numpy(type_arr)

        # ä¿ç•™ NumPy é™£åˆ—ä¾›åºåˆ—åŒ–å™¨ä½¿ç”¨
        self.agent_types_np = type_arr

        # é è¨­ç„¡ç›®æ¨™
        self.has_goal.fill(0)

    def _count_types(self) -> Dict[int, int]:
        """çµ±è¨ˆå„é¡å‹æ•¸é‡"""
        type_arr = self.agent_type.to_numpy()
        unique, counts = np.unique(type_arr, return_counts=True)
        return dict(zip(unique, counts))

    def set_goals(self, goals: np.ndarray, agent_indices: Optional[np.ndarray] = None):
        """
        è¨­å®šç›®æ¨™ä½ç½®

        Args:
            goals: ç›®æ¨™ä½ç½®é™£åˆ— (M, 3) æˆ– (3,)
            agent_indices: å“ªäº› agent æœ‰ç›®æ¨™ï¼ˆé è¨­ï¼šgoal_strength > 0 çš„ agentï¼‰
        """
        goals = np.atleast_2d(goals).astype(np.float32)

        if agent_indices is None:
            # è‡ªå‹•é¸æ“‡ï¼šgoal_strength > 0 çš„ agent
            goal_strength_arr = self.goal_strength.to_numpy()
            agent_indices = np.where(goal_strength_arr > 0)[0]

        assert len(goals) == len(agent_indices), (
            "goals æ•¸é‡å¿…é ˆèˆ‡ agent_indices æ•¸é‡ç›¸åŒ"
        )

        # è¨­å®šç›®æ¨™
        for i, idx in enumerate(agent_indices):
            self.goal[idx] = goals[i]
            self.has_goal[idx] = 1

    @ti.func
    def is_in_fov(self, vi: ti.template(), rij: ti.template()) -> ti.i32:
        """
        æª¢æŸ¥ j æ˜¯å¦åœ¨ i çš„è¦–é‡å…§

        Args:
            vi: agent i çš„é€Ÿåº¦å‘é‡
            rij: å¾ i æŒ‡å‘ j çš„å‘é‡ (xj - xi)

        Returns:
            1 if in FOV, 0 otherwise
        """
        in_fov = 1

        if ti.static(self.enable_fov):
            v_norm = vi.norm()
            r_norm = rij.norm()

            if v_norm > 1e-6 and r_norm > 1e-6:
                # cos(angle) = vi Â· rij / (|vi| |rij|)
                cos_angle = vi.dot(rij) / (v_norm * r_norm)
                # åœ¨è¦–é‡å…§ç•¶ cos(angle) > cos(fov_half_angle)
                if cos_angle < self.fov_cos_angle:
                    in_fov = 0
            else:
                # é€Ÿåº¦ç‚ºé›¶æˆ–è·é›¢ç‚ºé›¶ï¼Œè¦–ç‚ºåœ¨è¦–é‡å…§
                in_fov = 1

        return in_fov

    @ti.func
    def goal_seeking_force(self, i: ti.i32) -> ti.math.vec3:
        """è¨ˆç®—ç›®æ¨™å°å‘åŠ›ï¼ˆè€ƒæ…® PBCï¼‰"""
        force = ti.Vector([0.0, 0.0, 0.0])

        if self.has_goal[i] == 1:
            # ä½¿ç”¨ PBC-aware è·é›¢è¨ˆç®—
            direction = self.pbc_dist(self.x[i], self.goal[i])
            distance = direction.norm()

            if distance > 1e-6:
                # æ¨™æº–åŒ–æ–¹å‘ Ã— å¼·åº¦
                force = self.goal_strength[i] * direction / distance

        return force

    @ti.kernel
    def find_nearest_resources(self):
        """
        æ¯å€‹ agent æœå°‹æœ€è¿‘çš„æœ‰æ•ˆè³‡æº

        é‚è¼¯ï¼š
            â€¢ è‹¥ energy < threshold ä¸”ç„¡ç›®æ¨™ â†’ æœå°‹æœ€è¿‘è³‡æº
            â€¢ è¨ˆç®—åˆ°æ‰€æœ‰è³‡æºçš„è·é›¢
            â€¢ é¸æ“‡æœ€è¿‘ä¸”æœ‰æ•ˆçš„è³‡æº
        """
        N_res = self.resources.n_resources

        for i in self.x:
            energy = self.agent_energy[i]
            current_target = self.agent_target_resource[i]

            # æª¢æŸ¥æ˜¯å¦éœ€è¦è¦“é£Ÿ
            if energy < self.energy_threshold or current_target >= 0:
                min_dist = 1e10
                best_res = -1

                # æœå°‹æ‰€æœ‰è³‡æºï¼ˆrange-for é¿å… nested struct-forï¼‰
                for res_id in range(N_res):
                    if self.resources.resource_active[res_id] == 1:
                        if self.resources.resource_amount[res_id] > 0.0:
                            # è¨ˆç®—è·é›¢
                            res_pos = self.resources.resource_pos[res_id]

                            # è€ƒæ…® PBC
                            dx = ti.Vector([0.0, 0.0, 0.0])
                            if self.params.boundary_mode == 0:  # PBC
                                dx = self.pbc_dist(self.x[i], res_pos)
                            else:
                                dx = res_pos - self.x[i]

                            dist = dx.norm()

                            if dist < min_dist:
                                min_dist = dist
                                best_res = res_id

                # æ›´æ–°ç›®æ¨™
                self.agent_target_resource[i] = best_res

    @ti.kernel
    def find_nearest_prey(self):
        """
        æ é£Ÿè€…æœå°‹æœ€è¿‘çš„çµç‰©

        é‚è¼¯ï¼š
            â€¢ åªæœ‰ PREDATOR é¡å‹æœƒåŸ·è¡Œ
            â€¢ æœå°‹ç¯„åœå…§æœ€è¿‘ä¸”å­˜æ´»çš„éæ é£Ÿè€…
            â€¢ æ›´æ–° agent_target_prey[i]
        """
        for i in self.x:
            # åªæœ‰æ é£Ÿè€…æ‰è¿½æ•
            if (
                self.agent_type[i] == 3 and self.agent_alive[i] == 1
            ):  # AgentType.PREDATOR
                hunt_range = self.predator_hunt_range[i]
                min_dist = hunt_range
                best_prey = -1

                # æœå°‹æ‰€æœ‰å­˜æ´»çš„éæ é£Ÿè€…
                for j in range(self.N):
                    if i == j:
                        continue

                    # åªè¿½æ•å­˜æ´»ä¸”éæ é£Ÿè€…çš„ agent
                    if self.agent_alive[j] == 1 and self.agent_type[j] != 3:
                        # è¨ˆç®—è·é›¢ï¼ˆè€ƒæ…® PBCï¼‰
                        dx = ti.Vector([0.0, 0.0, 0.0])
                        if self.params.boundary_mode == 0:  # PBC
                            dx = self.pbc_dist(self.x[i], self.x[j])
                        else:
                            dx = self.x[j] - self.x[i]

                        dist = dx.norm()

                        if dist < min_dist:
                            min_dist = dist
                            best_prey = j

                # æ›´æ–°ç›®æ¨™çµç‰©
                self.agent_target_prey[i] = best_prey

    @ti.kernel
    def compute_forces(self):
        """
        è¨ˆç®—æ‰€æœ‰åŠ›ï¼ˆä½¿ç”¨å€‹é«”åƒæ•¸ + FOV + ç›®æ¨™å°å‘ï¼‰

        ä¿®æ”¹ï¼š
            â€¢ ä½¿ç”¨ beta_individual[i] å–ä»£å…¨åŸŸ beta
            â€¢ åŠ å…¥ FOV æª¢æŸ¥
            â€¢ åŠ å…¥ goal seeking force
        """
        # æ¸…ç©º
        for i in self.f:
            self.f[i] = ti.Vector([0.0, 0.0, 0.0])

        # è®€å–åƒæ•¸
        Ca, Cr = self.p[0], self.p[1]
        la, lr = self.p[2], self.p[3]
        rc = self.p[4]

        inv_la, inv_lr = 1.0 / la, 1.0 / lr
        rc2 = rc * rc

        # ä¸»å¾ªç’°
        for i in self.x:
            xi, vi = self.x[i], self.v[i]
            force = ti.Vector([0.0, 0.0, 0.0])
            v_sum = ti.Vector([0.0, 0.0, 0.0])
            n_neighbors = 0

            # å€‹é«”åƒæ•¸
            beta_i = self.beta_individual[i]

            for j in range(self.N):
                if i == j:
                    continue

                rij = self.pbc_dist(xi, self.x[j])
                r2 = rij.dot(rij)

                if r2 < 1e-6 or r2 > rc2:
                    continue

                r = ti.sqrt(r2)
                inv_r = 1.0 / r

                # Morse forceï¼ˆç„¡ FOV é™åˆ¶ï¼Œä¿æŒç‰©ç†ä¸€è‡´æ€§ï¼‰
                exp_a = ti.exp(-r * inv_la)
                exp_r = ti.exp(-r * inv_lr)
                coeff = Ca * inv_la * exp_a - Cr * inv_lr * exp_r
                force += coeff * rij * inv_r

                # Alignment forceï¼ˆå— FOV é™åˆ¶ï¼‰
                if beta_i > 0.0:
                    # FOV æª¢æŸ¥
                    if self.is_in_fov(vi, rij):
                        v_sum += self.v[j]
                        n_neighbors += 1

            # å„²å­˜ Morse åŠ›
            self.f[i] = force

            # Alignment force
            if beta_i > 0.0 and n_neighbors > 0:
                v_avg = v_sum / ti.cast(n_neighbors, ti.f32)
                self.f[i] += beta_i * (v_avg - vi)

            # Goal seeking force
            self.f[i] += self.goal_seeking_force(i)

            # Resource-seeking force
            target_res = self.agent_target_resource[i]
            if target_res >= 0:
                if self.resources.resource_active[target_res] == 1:
                    res_pos = self.resources.resource_pos[target_res]

                    # è¨ˆç®—æ–¹å‘ï¼ˆè€ƒæ…® PBCï¼‰
                    direction = ti.Vector([0.0, 0.0, 0.0])
                    if self.params.boundary_mode == 0:  # PBC
                        direction = self.pbc_dist(xi, res_pos)
                    else:
                        direction = res_pos - xi

                    dist = direction.norm()

                    if dist > 1e-6:
                        # æ–½åŠ å¸å¼•åŠ›ï¼ˆé¡ä¼¼ goal forceï¼‰
                        foraging_strength = 3.0  # å¯èª¿æ•´
                        self.f[i] += foraging_strength * (direction / dist)

            # Predator hunting force (æ é£Ÿè€…è¿½æ•)
            if self.agent_type[i] == 3 and self.agent_alive[i] == 1:  # PREDATOR
                target_prey = self.agent_target_prey[i]
                if target_prey >= 0 and self.agent_alive[target_prey] == 1:
                    # è¨ˆç®—æ–¹å‘ï¼ˆè€ƒæ…® PBCï¼‰
                    direction = ti.Vector([0.0, 0.0, 0.0])
                    if self.params.boundary_mode == 0:  # PBC
                        direction = self.pbc_dist(xi, self.x[target_prey])
                    else:
                        direction = self.x[target_prey] - xi

                    dist = direction.norm()

                    if dist > 1e-6:
                        # å¼·åŠ›è¿½æ•ï¼ˆæ¯”è¦“é£Ÿæ›´å¼·ï¼‰
                        hunt_strength = 5.0
                        self.f[i] += hunt_strength * (direction / dist)

            # Prey escape force (çµç‰©é€ƒè·‘)
            if self.agent_type[i] != 3 and self.agent_alive[i] == 1:  # éæ é£Ÿè€…
                # æª¢æŸ¥é™„è¿‘æ˜¯å¦æœ‰æ é£Ÿè€…
                escape_force = ti.Vector([0.0, 0.0, 0.0])
                escape_range = 15.0  # é€ƒè·‘æ„ŸçŸ¥ç¯„åœ

                for j in range(self.N):
                    if self.agent_type[j] == 3 and self.agent_alive[j] == 1:  # æ˜¯æ é£Ÿè€…
                        # è¨ˆç®—è·é›¢
                        dx = ti.Vector([0.0, 0.0, 0.0])
                        if self.params.boundary_mode == 0:  # PBC
                            dx = self.pbc_dist(xi, self.x[j])
                        else:
                            dx = self.x[j] - xi

                        dist = dx.norm()

                        if dist < escape_range and dist > 1e-6:
                            # é€ƒè·‘åŠ›èˆ‡è·é›¢æˆåæ¯”ï¼ˆè¶Šè¿‘è¶Šå¼·ï¼‰
                            escape_strength = 8.0 / (dist + 1.0)
                            escape_force -= escape_strength * (dx / dist)

                self.f[i] += escape_force

            # Obstacle avoidance force
            for obs_id in range(self.obstacles.n_obstacles):
                self.f[i] += self.obstacles.compute_obstacle_force(xi, obs_id)

    @ti.kernel
    def verlet_step2(self, dt: ti.f32):
        """
        Verlet ç¬¬äºŒæ­¥ï¼šä½¿ç”¨å€‹é«”åƒæ•¸

        ä¿®æ”¹ï¼š
            â€¢ ä½¿ç”¨ mass_individual[i], v0_individual[i], eta_individual[i]
        """
        alpha = self.p[5]

        for i in self.v:
            # å€‹é«”åƒæ•¸
            mass_i = self.mass_individual[i]
            v0_i = self.v0_individual[i]
            eta_i = self.eta_individual[i]

            # ä¿å®ˆåŠ›çš„ç¬¬äºŒå€‹åŠæ­¥
            a = self.f[i] / mass_i
            v_new = self.v[i] + 0.5 * dt * a

            # Rayleigh frictionï¼ˆå€‹é«”ç›®æ¨™é€Ÿåº¦ï¼‰
            v2 = v_new.dot(v_new)
            v0_sq = v0_i * v0_i
            rayleigh_coeff = alpha * (1.0 - v2 / (v0_sq + 1e-12))
            v_new += dt * rayleigh_coeff * v_new

            # Vicsek noiseï¼ˆå€‹é«” noise å¼·åº¦ï¼‰
            if eta_i > 0.0:
                speed = ti.sqrt(v_new.dot(v_new))
                if speed > 1e-6:
                    # æ›´æ–° RNG ç‹€æ…‹
                    state = self.rng_state[i]

                    # Random 1: æ—‹è½‰è§’åº¦
                    state = self.xorshift32(state)
                    rand1 = self.rand_uniform(state)
                    noise_angle = (rand1 - 0.5) * 2.0 * eta_i

                    # Random 2-3: éš¨æ©Ÿæ—‹è½‰è»¸
                    state = self.xorshift32(state)
                    rand2 = self.rand_uniform(state)
                    state = self.xorshift32(state)
                    rand3 = self.rand_uniform(state)

                    u = rand2 * 2.0 - 1.0
                    v = rand3 * 2.0 - 1.0
                    s = u * u + v * v

                    # åˆå§‹åŒ–æ—‹è½‰è»¸
                    axis = ti.Vector([1.0, 0.0, 0.0])

                    if s < 1.0 and s > 1e-6:
                        # Marsaglia æ–¹æ³•
                        sqrt_factor = ti.sqrt(1.0 - s)
                        axis = ti.Vector(
                            [
                                2.0 * u * sqrt_factor,
                                2.0 * v * sqrt_factor,
                                1.0 - 2.0 * s,
                            ]
                        )
                    else:
                        # Fallback
                        v_norm = v_new / speed
                        if ti.abs(v_norm[0]) < ti.abs(v_norm[1]):
                            if ti.abs(v_norm[0]) < ti.abs(v_norm[2]):
                                axis = ti.Vector([0.0, -v_norm[2], v_norm[1]])
                            else:
                                axis = ti.Vector([-v_norm[1], v_norm[0], 0.0])
                        else:
                            if ti.abs(v_norm[1]) < ti.abs(v_norm[2]):
                                axis = ti.Vector([-v_norm[2], 0.0, v_norm[0]])
                            else:
                                axis = ti.Vector([-v_norm[1], v_norm[0], 0.0])

                    # æ­£è¦åŒ–æ—‹è½‰è»¸
                    axis_norm = ti.sqrt(axis.dot(axis))
                    if axis_norm > 1e-6:
                        axis /= axis_norm

                    # Rodrigues' rotation
                    cos_angle = ti.cos(noise_angle)
                    sin_angle = ti.sin(noise_angle)

                    v_norm = v_new / speed
                    k_cross_v = ti.Vector(
                        [
                            axis[1] * v_norm[2] - axis[2] * v_norm[1],
                            axis[2] * v_norm[0] - axis[0] * v_norm[2],
                            axis[0] * v_norm[1] - axis[1] * v_norm[0],
                        ]
                    )
                    k_dot_v = axis.dot(v_norm)

                    v_rotated = (
                        v_norm * cos_angle
                        + k_cross_v * sin_angle
                        + axis * k_dot_v * (1.0 - cos_angle)
                    )

                    v_new = v_rotated * speed
                    self.rng_state[i] = state

            self.v[i] = v_new

    # ========================================================================
    # Resource/Foraging Methods
    # ========================================================================
    @ti.kernel
    def _update_energy_consumption(self):
        """æ›´æ–°æ‰€æœ‰ agent çš„èƒ½é‡æ¶ˆè€—"""
        for i in self.agent_energy:
            # ç§»å‹•æ¶ˆè€—èƒ½é‡
            self.agent_energy[i] = ti.max(
                0.0, self.agent_energy[i] - self.energy_consumption_rate
            )

    def consume_resources_step(self, consumption_rate: float = 10.0):
        """
        è™•ç†è³‡æºæ¶ˆè€—ï¼ˆæ¯æ­¥å‘¼å«ä¸€æ¬¡ï¼‰

        Args:
            consumption_rate: æ¯æ­¥æ¶ˆè€—è³‡æºçš„é€Ÿç‡
        """
        # å…ˆæ›´æ–°èƒ½é‡æ¶ˆè€—
        self._update_energy_consumption()

        # æª¢æŸ¥æ¯å€‹ agent æ˜¯å¦åœ¨è³‡æºç¯„åœå…§
        x_np = self.x.to_numpy()
        target_res_np = self.agent_target_resource.to_numpy()

        for i in range(len(x_np)):
            target_res = target_res_np[i]
            if target_res >= 0 and target_res < self.resources.n_resources:
                # ç²å–ä½ç½®èˆ‡ç¯„åœ
                agent_pos = x_np[i]
                res_pos = self.resources.resource_pos[target_res].to_numpy()
                res_radius = self.resources.resource_radius[target_res]

                # è¨ˆç®—è·é›¢ï¼ˆç°¡å–®æ­å¼è·é›¢ï¼Œå¯æ“´å±• PBCï¼‰
                distance = np.linalg.norm(agent_pos - res_pos)

                if distance < res_radius:
                    # åœ¨ç¯„åœå…§ï¼šæ¶ˆè€—è³‡æºã€å¢åŠ èƒ½é‡
                    consumed = self.resources.consume_resource(
                        target_res, consumption_rate
                    )

                    # å¢åŠ  agent èƒ½é‡
                    current_energy = self.agent_energy[i]
                    self.agent_energy[i] = min(100.0, current_energy + consumed)

                    # è‹¥è³‡æºè€—ç›¡æˆ–èƒ½é‡å·²æ»¿ï¼Œæ¸…é™¤ç›®æ¨™
                    if consumed <= 0.0 or self.agent_energy[i] >= 100.0:
                        self.agent_target_resource[i] = -1

    # Resource management API
    def add_resource(self, config: ResourceConfig) -> int:
        """æ–°å¢è³‡æº"""
        return self.resources.add_resource(config)

    def remove_resource(self, res_id: int):
        """ç§»é™¤è³‡æº"""
        self.resources.remove_resource(res_id)

    def get_resource_info(self, res_id: int):
        """ç²å–è³‡æºè³‡è¨Š"""
        return self.resources.get_resource_info(res_id)

    def get_all_resources(self):
        """ç²å–æ‰€æœ‰è³‡æº"""
        return self.resources.get_all_resources()

    # ========================================================================
    # Predator/Prey Methods
    # ========================================================================
    def attack_prey_step(self):
        """
        è™•ç†æ é£Ÿè€…æ”»æ“Šï¼ˆæ¯æ­¥å‘¼å«ä¸€æ¬¡ï¼‰

        é‚è¼¯ï¼š
            â€¢ æ é£Ÿè€…åœ¨æ”»æ“Šç¯„åœå…§æ•é£Ÿçµç‰©
            â€¢ çµç‰©è¢«æ¨™è¨˜ç‚º agent_alive = 0
            â€¢ æ é£Ÿè€…ç²å¾—èƒ½é‡ï¼ˆå¯é¸ï¼‰
        """
        x_np = self.x.to_numpy()
        target_prey_np = self.agent_target_prey.to_numpy()
        alive_np = self.agent_alive.to_numpy()
        agent_type_np = self.agent_type.to_numpy()

        for i in range(len(x_np)):
            # åªæœ‰å­˜æ´»çš„æ é£Ÿè€…æ‰èƒ½æ”»æ“Š
            if agent_type_np[i] == 3 and alive_np[i] == 1:  # PREDATOR
                target_prey = target_prey_np[i]

                if target_prey >= 0 and alive_np[target_prey] == 1:
                    # è¨ˆç®—è·é›¢
                    predator_pos = x_np[i]
                    prey_pos = x_np[target_prey]
                    distance = np.linalg.norm(predator_pos - prey_pos)

                    # ç²å–æ”»æ“Šç¯„åœ
                    attack_range = self.predator_attack_range[i]

                    if distance < attack_range:
                        # æ•é£ŸæˆåŠŸï¼
                        self.agent_alive[target_prey] = 0
                        self.agent_target_prey[i] = -1  # æ¸…é™¤ç›®æ¨™

                        # æ é£Ÿè€…ç²å¾—èƒ½é‡ï¼ˆå¯é¸ï¼‰
                        current_energy = self.agent_energy[i]
                        self.agent_energy[i] = min(100.0, current_energy + 50.0)

                        print(f"ğŸ¦ Predator {i} captured prey {target_prey}!")

    def get_alive_count(self) -> int:
        """ç²å–å­˜æ´» agent æ•¸é‡"""
        return int(self.agent_alive.to_numpy().sum())

    def get_predator_count(self) -> int:
        """ç²å–æ é£Ÿè€…æ•¸é‡"""
        agent_type_np = self.agent_type.to_numpy()
        return int((agent_type_np == 3).sum())

    def get_prey_count(self) -> int:
        """ç²å–çµç‰©æ•¸é‡ï¼ˆéæ é£Ÿè€…ä¸”å­˜æ´»ï¼‰"""
        agent_type_np = self.agent_type.to_numpy()
        alive_np = self.agent_alive.to_numpy()
        return int(((agent_type_np != 3) & (alive_np == 1)).sum())

    # ========================================================================
    # Group Detection Methods
    # ========================================================================
    # Obstacle Management Methods
    # ========================================================================
    def add_obstacle(self, config: ObstacleConfig) -> int:
        """
        æ–°å¢éšœç¤™ç‰©

        Args:
            config: éšœç¤™ç‰©é…ç½®

        Returns:
            éšœç¤™ç‰© ID
        """
        return self.obstacles.add_obstacle(config)

    def remove_obstacle(self, obs_id: int):
        """ç§»é™¤éšœç¤™ç‰©"""
        self.obstacles.remove_obstacle(obs_id)

    def update_obstacle_position(self, obs_id: int, new_pos: np.ndarray):
        """æ›´æ–°éšœç¤™ç‰©ä½ç½®ï¼ˆæ”¯æ´å‹•æ…‹éšœç¤™ç‰©ï¼‰"""
        self.obstacles.update_obstacle_position(obs_id, new_pos)

    def get_obstacle_info(self, obs_id: int) -> dict:
        """ç²å–éšœç¤™ç‰©è³‡è¨Š"""
        return self.obstacles.get_obstacle_info(obs_id)

    def get_all_obstacles(self) -> List[dict]:
        """ç²å–æ‰€æœ‰éšœç¤™ç‰©è³‡è¨Š"""
        return self.obstacles.get_all_obstacles()

    # ========================================================================
    # Spatial Grid Methods (for accelerating group detection)
    # ========================================================================
    @ti.func
    def get_cell_id(self, pos: ti.template()) -> ti.i32:
        """
        è¨ˆç®—ä½ç½®å°æ‡‰çš„ cell ID

        Args:
            pos: 3D ä½ç½®å‘é‡

        Returns:
            cell_id: ä¸€ç¶­ cell index
        """
        # å°‡ä½ç½®å¾ [-box_size/2, box_size/2] æ˜ å°„åˆ° [0, grid_resolution]
        half_box = self.params.box_size / 2.0

        ix = ti.cast((pos[0] + half_box) / self.grid_cell_size, ti.i32)
        iy = ti.cast((pos[1] + half_box) / self.grid_cell_size, ti.i32)
        iz = ti.cast((pos[2] + half_box) / self.grid_cell_size, ti.i32)

        # é‚Šç•Œè™•ç†ï¼šclamp åˆ° [0, grid_resolution-1]
        ix = ti.max(0, ti.min(ix, self.grid_resolution - 1))
        iy = ti.max(0, ti.min(iy, self.grid_resolution - 1))
        iz = ti.max(0, ti.min(iz, self.grid_resolution - 1))

        # ä¸€ç¶­åŒ–ï¼šcell_id = ix + iy * res + iz * resÂ²
        cell_id = (
            ix
            + iy * self.grid_resolution
            + iz * self.grid_resolution * self.grid_resolution
        )

        return cell_id

    @ti.kernel
    def assign_agents_to_grid(self):
        """
        å°‡æ‰€æœ‰ agent åˆ†é…åˆ°å°æ‡‰çš„ spatial grid cell
        æ™‚é–“è¤‡é›œåº¦ï¼šO(N)
        """
        # é‡ç½® cell_count
        for c in self.cell_count:
            self.cell_count[c] = 0

        # ç¬¬ä¸€éï¼šè¨ˆç®—æ¯å€‹ agent çš„ cell_id
        for i in self.x:
            # æ’é™¤æ é£Ÿè€…
            if self.agent_type[i] == 3:
                self.agent_cell_id[i] = -1
                continue

            cell_id = self.get_cell_id(self.x[i])
            self.agent_cell_id[i] = cell_id

            # åŸå­æ“ä½œï¼šè¨ˆæ•¸è©² cell çš„ agent æ•¸é‡
            old_count = ti.atomic_add(self.cell_count[cell_id], 1)

            # å°‡ agent åŠ å…¥è©² cellï¼ˆå¦‚æœæœªæ»¿ï¼‰
            if old_count < self.max_agents_per_cell:
                self.cell_agents[cell_id, old_count] = i

    @ti.func
    def get_neighbor_cells(self, cell_id: ti.i32) -> ti.types.vector(27, ti.i32):
        """
        ç²å–æŒ‡å®š cell çš„æ‰€æœ‰é„°å±… cellï¼ˆåŒ…å«è‡ªå·±ï¼‰

        Args:
            cell_id: ä¸­å¿ƒ cell çš„ ID

        Returns:
            neighbor_cells: æœ€å¤š 27 å€‹é„°å±… cell çš„ IDï¼ˆ3Ã—3Ã—3ï¼‰
        """
        # è§£æ cell_id ç‚º (ix, iy, iz)
        res = self.grid_resolution
        iz = cell_id // (res * res)
        remainder = cell_id % (res * res)
        iy = remainder // res
        ix = remainder % res

        # éæ­· 3Ã—3Ã—3 çš„é„°å±… cell
        neighbors = ti.Vector([0] * 27, dt=ti.i32)
        count = 0

        for dz in ti.static(range(-1, 2)):
            for dy in ti.static(range(-1, 2)):
                for dx in ti.static(range(-1, 2)):
                    nx = ix + dx
                    ny = iy + dy
                    nz = iz + dz

                    # é‚Šç•Œæª¢æŸ¥
                    if (
                        nx >= 0
                        and nx < res
                        and ny >= 0
                        and ny < res
                        and nz >= 0
                        and nz < res
                    ):
                        neighbor_cell = nx + ny * res + nz * res * res
                        neighbors[count] = neighbor_cell
                        count += 1

        # å‰©é¤˜ä½ç½®å¡« -1ï¼ˆç„¡æ•ˆï¼‰
        for k in range(count, 27):
            neighbors[k] = -1

        return neighbors

    # ========================================================================
    # Group Detection Methods
    # ========================================================================
    @ti.kernel
    def detect_groups_iteration(self, r_cluster: ti.f32, theta_cluster: ti.f32):
        """
        åŸ·è¡Œå–®æ¬¡ç¾¤çµ„åµæ¸¬è¿­ä»£ï¼ˆlabel propagation çš„ä¸€è¼ªï¼‰
        ä½¿ç”¨ Spatial Grid åŠ é€Ÿé„°å±…æœå°‹ï¼šO(N) å–ä»£ O(NÂ²)

        æ¢ä»¶ï¼š
            â€¢ å…©å€‹ agents è·é›¢ < r_cluster
            â€¢ é€Ÿåº¦å¤¾è§’ < theta_cluster

        Args:
            r_cluster: èšé¡è·é›¢é–¾å€¼
            theta_cluster: é€Ÿåº¦å¤¾è§’é–¾å€¼ï¼ˆå¼§åº¦ï¼‰
        """
        for i in self.x:
            # æ’é™¤æ é£Ÿè€…ï¼ˆtype=3ï¼‰ä¸åƒèˆ‡ç¾¤çµ„æª¢æ¸¬
            if self.agent_type[i] == 3:
                self.group_id[i] = -1
                continue

            xi = self.x[i]
            vi = self.v[i]
            vi_norm = vi.norm()

            if vi_norm < 1e-6:
                continue

            current_group = self.group_id[i]
            min_group = current_group

            # ç²å– agent i æ‰€åœ¨çš„ cell
            cell_id = self.agent_cell_id[i]
            if cell_id < 0:  # ç„¡æ•ˆ cellï¼ˆä¸æ‡‰è©²ç™¼ç”Ÿï¼‰
                continue

            # è§£æ cell_id ç‚º 3D index (ix, iy, iz)
            res = self.grid_resolution
            iz = cell_id // (res * res)
            remainder = cell_id % (res * res)
            iy = remainder // res
            ix = remainder % res

            # åªæª¢æŸ¥ 3Ã—3Ã—3=27 å€‹ç›¸é„° cell ä¸­çš„ agentsï¼ˆå–ä»£åŸæœ¬çš„ O(N) å…¨å±€æœå°‹ï¼‰
            for dz in ti.static(range(-1, 2)):
                for dy in ti.static(range(-1, 2)):
                    for dx in ti.static(range(-1, 2)):
                        nx = ix + dx
                        ny = iy + dy
                        nz = iz + dz

                        # é‚Šç•Œæª¢æŸ¥ï¼šåªè™•ç†æœ‰æ•ˆçš„é„°å±… cell
                        if (
                            nx >= 0
                            and nx < res
                            and ny >= 0
                            and ny < res
                            and nz >= 0
                            and nz < res
                        ):
                            neighbor_cell = nx + ny * res + nz * res * res

                            # æª¢æŸ¥è©² cell ä¸­çš„æ‰€æœ‰ agents
                            n_agents_in_cell = self.cell_count[neighbor_cell]
                            for local_idx in range(n_agents_in_cell):
                                if local_idx >= self.max_agents_per_cell:
                                    break

                                j = self.cell_agents[neighbor_cell, local_idx]
                                if i == j:
                                    continue

                                # æ’é™¤æ é£Ÿè€…
                                if self.agent_type[j] == 3:
                                    continue

                                xj = self.x[j]
                                vj = self.v[j]
                                vj_norm = vj.norm()

                                if vj_norm < 1e-6:
                                    continue

                                # è¨ˆç®—è·é›¢ï¼ˆè€ƒæ…® PBCï¼‰
                                distance = 0.0
                                if self.params.boundary_mode == 0:  # PBC
                                    distance = self.pbc_dist(xi, xj).norm()
                                else:
                                    distance = (xj - xi).norm()

                                # æª¢æŸ¥ç©ºé–“æ¥è¿‘åº¦
                                if distance > r_cluster:
                                    continue

                                # æª¢æŸ¥é€Ÿåº¦å¤¾è§’
                                cos_angle = (vi.dot(vj)) / (vi_norm * vj_norm)
                                # è™•ç†æ•¸å€¼èª¤å·®
                                cos_angle = ti.max(-1.0, ti.min(1.0, cos_angle))
                                angle = ti.acos(cos_angle)

                                if angle > theta_cluster:
                                    continue

                                # æ»¿è¶³æ¢ä»¶ï¼šå–è¼ƒå°çš„ group_id
                                neighbor_group = self.group_id[j]
                                if neighbor_group < min_group:
                                    min_group = neighbor_group

            # æ›´æ–° group_id
            self.group_id[i] = min_group

    @ti.kernel
    def compute_group_statistics(self):
        """
        è¨ˆç®—æ¯å€‹ç¾¤çµ„çš„çµ±è¨ˆè³‡è¨Š

        è¨ˆç®—ï¼š
            â€¢ group_size: ç¾¤çµ„å¤§å°
            â€¢ group_centroid: è³ªå¿ƒä½ç½®
            â€¢ group_velocity: å¹³å‡é€Ÿåº¦
        """
        # é‡ç½®çµ±è¨ˆè³‡è¨Š
        for g in range(self.max_groups):
            self.group_size[g] = 0
            self.group_centroid[g] = ti.Vector([0.0, 0.0, 0.0])
            self.group_velocity[g] = ti.Vector([0.0, 0.0, 0.0])
            self.group_active[g] = 0

        # ç¬¬ä¸€è¼ªï¼šè¨ˆç®—æ¯å€‹ç¾¤çµ„çš„ç¸½å’Œï¼ˆæ’é™¤æ é£Ÿè€…ï¼‰
        for i in self.x:
            # æ é£Ÿè€…ä¸åƒèˆ‡ç¾¤çµ„çµ±è¨ˆ
            if self.agent_type[i] == 3:
                continue

            gid = self.group_id[i]
            if gid >= 0 and gid < self.max_groups:
                # ä½¿ç”¨ atomic add é¿å… race condition
                ti.atomic_add(self.group_size[gid], 1)
                for d in ti.static(range(3)):
                    ti.atomic_add(self.group_centroid[gid][d], self.x[i][d])
                    ti.atomic_add(self.group_velocity[gid][d], self.v[i][d])

        # ç¬¬äºŒè¼ªï¼šè¨ˆç®—å¹³å‡å€¼ä¸¦æ¨™è¨˜æœ‰æ•ˆç¾¤çµ„
        for g in range(self.max_groups):
            size = self.group_size[g]
            if size > 0:
                self.group_active[g] = 1
                # è¨ˆç®—å¹³å‡å€¼
                for d in ti.static(range(3)):
                    self.group_centroid[g][d] /= ti.cast(size, ti.f32)
                    self.group_velocity[g][d] /= ti.cast(size, ti.f32)

    def update_groups(
        self, r_cluster: float = 5.0, theta_cluster: float = 30.0, n_iterations: int = 5
    ):
        """
        æ›´æ–°ç¾¤çµ„åµæ¸¬ï¼ˆPython ä»‹é¢ï¼‰
        ä½¿ç”¨ Spatial Grid åŠ é€Ÿï¼šO(N) å–ä»£ O(NÂ²)

        Args:
            r_cluster: èšé¡è·é›¢é–¾å€¼
            theta_cluster: é€Ÿåº¦å¤¾è§’é–¾å€¼ï¼ˆåº¦æ•¸ï¼‰
            n_iterations: è¿­ä»£æ¬¡æ•¸
        """
        theta_rad = np.radians(theta_cluster)

        # å‹•æ…‹æ›´æ–° grid_cell_sizeï¼ˆç¢ºä¿ cell_size = r_clusterï¼‰
        self.grid_cell_size = r_cluster
        self.grid_resolution = max(
            int(self.params.box_size / r_cluster) + 1, 4
        )  # æœ€å° 4Ã—4Ã—4

        # Step 1: å°‡ agents åˆ†é…åˆ° spatial gridï¼ˆO(N)ï¼‰
        self.assign_agents_to_grid()

        # Step 2: åˆå§‹åŒ–ï¼šæ¯å€‹ agent è‡ªå·±æ˜¯ä¸€å€‹ç¾¤çµ„
        self.group_id.fill(-1)
        for i in range(len(self.x.to_numpy())):
            # æ é£Ÿè€…ä¸åƒèˆ‡ç¾¤çµ„
            if self.agent_types_np[i] != 3:
                self.group_id[i] = i

        # Step 3: åŸ·è¡Œå¤šè¼ªè¿­ä»£ï¼ˆä½¿ç”¨ Grid åŠ é€Ÿçš„é„°å±…æœå°‹ï¼‰
        for iteration in range(n_iterations):
            self.detect_groups_iteration(r_cluster, theta_rad)

        # Step 4: è¨ˆç®—ç¾¤çµ„çµ±è¨ˆ
        self.compute_group_statistics()

    def get_group_info(self, group_id: int) -> Optional[dict]:
        """
        ç²å–ç¾¤çµ„è³‡è¨Š

        Args:
            group_id: ç¾¤çµ„ ID

        Returns:
            ç¾¤çµ„è³‡è¨Šå­—å…¸ï¼Œè‹¥ç¾¤çµ„ç„¡æ•ˆå‰‡è¿”å› None
        """
        if group_id < 0 or group_id >= self.max_groups:
            return None

        if self.group_active[group_id] == 0:
            return None

        return {
            "group_id": group_id,
            "size": self.group_size[group_id],
            "centroid": self.group_centroid[group_id].to_numpy(),
            "velocity": self.group_velocity[group_id].to_numpy(),
        }

    def get_all_groups(self) -> List[dict]:
        """ç²å–æ‰€æœ‰æœ‰æ•ˆç¾¤çµ„çš„è³‡è¨Š"""
        groups = []
        for g in range(self.max_groups):
            info = self.get_group_info(g)
            if info is not None:
                groups.append(info)
        return groups

    def get_agent_groups(self) -> np.ndarray:
        """ç²å–æ¯å€‹ agent çš„ç¾¤çµ„ IDï¼ˆè¿”å› numpy é™£åˆ—ï¼‰"""
        return self.group_id.to_numpy()

    def step(self, dt: float):
        """
        åŸ·è¡Œä¸€å€‹æ™‚é–“æ­¥ï¼ˆè¦†å¯«çˆ¶é¡åˆ¥æ–¹æ³•ä»¥æ•´åˆç•°è³ªèˆ‡æ•é£Ÿè€…é‚è¼¯ï¼‰

        æ•´åˆé †åºï¼š
            1. æ›´æ–°è³‡æºèˆ‡çµç‰©ç›®æ¨™
            2. è¨ˆç®—åŠ›ï¼ˆåŒ…å«æ•é£Ÿ/é€ƒè„«åŠ›ï¼‰
            3. Verlet ç©åˆ†å™¨
            4. è³‡æºæ¶ˆè€—èˆ‡æ•é£Ÿæ”»æ“Š
            5. è³‡æºå†ç”Ÿ
            6. ç¾¤çµ„æª¢æ¸¬ï¼ˆæ¯ N æ­¥åŸ·è¡Œä¸€æ¬¡ï¼‰
        """
        # 1. æ›´æ–°ç›®æ¨™
        self.find_nearest_resources()  # ä½èƒ½é‡ agent å°‹æ‰¾è³‡æº
        self.find_nearest_prey()  # æ•é£Ÿè€…é–å®šçµç‰©

        # 2-3. ç‰©ç†æ›´æ–°ï¼ˆVelocity Verletï¼‰
        self.compute_forces()  # è¨ˆç®—æ‰€æœ‰åŠ›ï¼ˆå«æ•é£Ÿ/é€ƒè„«ï¼‰
        self.verlet_step1(dt)
        self.compute_forces()
        self.verlet_step2(dt)

        # 4. ç”Ÿæ…‹äº’å‹•
        self.consume_resources_step(consumption_rate=10.0)  # Agent æ¶ˆè€—è³‡æº
        self.attack_prey_step()  # æ•é£Ÿè€…æ”»æ“Šçµç‰©

        # 5. ç’°å¢ƒæ›´æ–°
        self.resources.replenish_resources()  # è³‡æºå†ç”Ÿ

        # 6. ç¾¤çµ„æª¢æ¸¬ï¼ˆæ¯ N æ­¥åŸ·è¡Œä¸€æ¬¡ä»¥æ¸›å°‘è¨ˆç®—è² æ“”ï¼‰
        # ç¬¬ä¸€æ­¥ï¼ˆstep_counter=0ï¼‰å¼·åˆ¶åŸ·è¡Œä¸€æ¬¡ï¼Œç¢ºä¿æœ‰åˆå§‹ç¾¤çµ„è³‡æ–™
        # é™ä½è¿­ä»£æ¬¡æ•¸ï¼š5 â†’ 3ï¼ˆLabel Propagation æ”¶æ–‚å¾ˆå¿«ï¼‰
        if self.step_counter == 0 or self.step_counter >= self.group_detection_interval:
            self.update_groups(r_cluster=5.0, theta_cluster=30.0, n_iterations=3)
            self.step_counter = 1  # é‡ç½®ç‚º 1ï¼ˆä¸‹æ¬¡åœ¨ interval æ™‚åŸ·è¡Œï¼‰
        else:
            self.step_counter += 1


# ============================================================================
# Demo & Testing Utilities
# ============================================================================
# Demo & Testing Utilities
# ============================================================================
if __name__ == "__main__":
    print("=" * 70)
    print("Heterogeneous Flocking 3D - Quick Test")
    print("=" * 70)

    # å»ºç«‹æ··åˆç¾¤é«”ï¼š20% Explorer, 70% Follower, 10% Leader
    N = 100
    agent_types = (
        [AgentType.EXPLORER] * 20 + [AgentType.FOLLOWER] * 70 + [AgentType.LEADER] * 10
    )

    params = FlockingParams(
        Ca=1.5,
        Cr=2.0,
        la=2.5,
        lr=0.5,
        rc=15.0,
        alpha=2.0,
        beta=1.0,  # åŸºç¤å€¼ï¼ˆæœƒè¢«å€‹é«”åƒæ•¸è¦†è“‹ï¼‰
        box_size=50.0,
    )

    system = HeterogeneousFlocking3D(
        N=N, params=params, agent_types=agent_types, enable_fov=True, fov_angle=120.0
    )

    system.initialize(box_size=5.0, seed=42)

    # è¨­å®šç›®æ¨™ï¼šLeaders å‘ (10, 10, 10) ç§»å‹•
    leader_indices = np.where(np.array(agent_types) == AgentType.LEADER)[0]
    goals = np.tile([10.0, 10.0, 10.0], (len(leader_indices), 1))
    system.set_goals(goals, leader_indices)

    print("\nåŸ·è¡Œ 100 æ­¥æ¨¡æ“¬...")
    system.run(steps=100, dt=0.01, log_every=20)

    print("\n" + "=" * 70)
    print("âœ… Quick test å®Œæˆ")
    print("=" * 70)
